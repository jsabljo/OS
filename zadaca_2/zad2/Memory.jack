/**
 * Memory operations library.
 */ 
class Memory
{
    static Array ram;
    static Array freeList;
    
    /** Initializes memory parameters. */
    function void init()
    {
        let ram = 0;
        
        // set heap and free list to 2048 (heap top)
        let freeList = 2048;
        
        // initial values
        let freeList[0] = 0;     // no next block at start
        let freeList[1] = 14334; // initial block length, 16384 - 2048 - 1
        
        return;
    }

    /** Returns the value of the main memory at the given address. */
    function int peek(int address)
    {
        return ram[address];
    }

    /** Sets the value of the main memory at this address
     *  to the given value. */
    function void poke(int address, int value)
    {
        let ram[address] = value;
        return;
    }

    /** finds and allocates from the heap a memory block of the 
     *  specified size and returns a reference to its base address. */
    function int alloc(int size)
    {
        var int curr, next, len, new;
        var boolean break;
        let break = true;
        let curr = freeList;
        do Output.printInt(11111);
        do Output.println();
        
        // iterate through all blocks
        while (~(curr = 0))
        {
            let next = ram[curr];
            let len = ram[curr + 1];

            do Output.printInt(next);
            
            // check if current block is large enough
            if (~(len < (size + 2))) // len >= size + 2
            {
                // the block is large enough, use it (first fit) 
                
                let ram[curr + 1] = len - size - 2;
                
                let new = curr + len - size;
                let ram[new] = 0;
                let ram[new + 1] = size;
                
                // return first element
                return new + 2;
            }            
            
            let curr = next;
            
            if ((curr = 0) & break){
                let break = false;
                do Memory.sort();
                do Output.printString("sort");
                let curr = freeList;
                return 1234;
            }
            
        }
        return freeList;
    }

    
    /** De-allocates the given object and frees its space. */
    function void deAlloc(int object)
    {
        var int curr, next;
        let curr = freeList;
        
        // iterate through all blocks
        while (~(curr = 0))
        {
            let next = ram[curr];
            if (next = 0){
                let ram[curr] = object;
                let ram[object] = 0;
                return;
            }
            let curr = next;
            
        }
        return;
    }
    function void sort(){
        var int curr, next, next_prev, prev_curr, pom, i;

        let curr = freeList;
        let prev_curr = curr;
        do Output.printInt(12345);
        do Output.println();
        while(~(curr = 0)){

            let next = ram[curr];
            let next_prev = curr;
            do Output.printString("c");
            do Output.printInt(curr);
            
            while(~(next = 0)){
                // next = [1,3] , curr[4,7]
                do Output.printInt(next);
                do Output.printString("-");
                if(next + ram[next + 1] + 1 < curr){
                    do Output.printString("--");
                    do Output.printInt(next);
                    if(~(next_prev = curr)){
                        let ram[next_prev] = curr;
                    }
                    if (prev_curr = curr){
                        let pom = ram[next];
                        let ram[next] = ram[curr];
                        let ram[curr] = pom;
                    }else{
                        let ram[prev_curr] = next;
                        let pom = ram[next];
                        let ram[next] = ram[curr];
                        let ram[curr] = pom;

                    }
                }
                if ( i = 5){
                    return;
                }
                let i = i + 1;

                let next_prev = next;
                let next = ram[next];            
            }
            let prev_curr = curr;
            let curr = ram[curr];
        }
        return ;
        
    }
    
    function void defrag()
    {
        var int curr, next;

        do Memory.sort();
        let curr = freeList;
        let next = ram[curr];

        while(~(next = 0))
        {
            if(curr + ram[curr + 1] = next)
            {
                let ram[curr + 1] = ram[curr + 1] + ram[next + 1];
                let ram[curr] = ram[next];
                let ram[next + 1] = null;
                let ram[next] = null;
            }

            let curr = next;
            let next = ram[curr];
        }

        return;
    }
    
    
    

    function void memcpy(int izvor, int odrediste, int d)
    {
        var int i;
        // izvor i odrediste su bas pointeri na prvi podatak

        while (i < d){

            let ram[odrediste + i] = ram[izvor + i];

            let i = i + 1;
        }

        return ;
    }  

/*
    function void defrag()
    {
        var int curr, next, prev_curr, prev_next;
        var boolean break;
        let break = false;
        let curr = freeList;
        let prev_curr = freeList;
        do Output.printString("defr");
        
        // iterate through all blocks
        while (~(curr = 0))
        {
            let next = ram[curr];
            let prev_next = curr;

     
            while ( ~(next = 0))
            {
            
                //[4,7] i next je [1,3]
                if (next + ram[next + 1] + 1 + 1 = curr){
                    if (~(prev_curr = 0)){
                        let ram[prev_curr] = next;
                    }
                    let ram[next + 1] = ram[next + 1] + 2 + ram[curr + 1];
                    let ram[prev_next] = ram[next];
                    let ram[next] = ram[curr];
                    let curr = next;
                }

                if (curr + ram[curr + 1] + 1 + 1 = next){
                    let ram[curr + 1] = ram[curr + 1] + 2 + ram[next + 1];
                    let ram[prev_next] = ram[next];
                    let next = curr;
                }

                let prev_next = next;

                let next = ram[next];    

            }
            let curr = ram[curr];
            let prev_curr = curr;

            
        }
        return;
    }  
    */
    
}